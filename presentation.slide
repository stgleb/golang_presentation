Golang from python point of view
Tags: go, python

Gleb Stepanov
Software engineer, Mirantis
gstepanov@mirantis.com

Thank you!

* Short description

Go is a compiled, concurrent, garbage-collected, statically typed language developed at Google.
.image images/gopher.png 300 200

* Supported OS by echo $GOOS

- linux
- windows
- darwin
- solaris
- freebsd
- netbsd
- openbsd
- dragonfly
- android
- plan9

* Supported architectures by echo $GOARCH

- arm
- arm64
- amd64
- 386
- ppc64
- ppc64le
- mips64
- mips64le

* Golang has compact syntax

Keywords Golang:

    break        default      func         interface    select
    case         defer        go           map          struct
    chan         else         goto         package      switch
    const        fallthrough  if           range        type
    continue     for          import       return       var

Keywords Python:

    and          del          from         not          while
    as           elif         global       or           with
    assert       else         if           pass         yield
    break        except       import       print
    class        exec         in           raise
    continue     finally      is           return
    def          for          lambda       try

* First program

Golang also has unicode support
.code src/hello_world.go

All Go source is part of a package. Every file begins with a package statement.
Programs start in package main.

* Basic syntax is closer to Pascal than to C

Variable declaration

    var a int

Short variable declaration

    a := 2

Function declaration

    func foo() int {
        ...
    }

* Imports

Imports must be placed right after package name declaration

    package foo

    import "encoding/json"

Imports can be directly made from git repositories

    import "github.com/valyala/fasthttp"

Import may be declared with aliases

    import j "encoding/json"

* More imports

Or can be done with . analog of from x import *

    import . "encoding/json"

To import a package solely for its side-effects (initialization),
use the blank identifier as explicit package name

    _ "github.com/go-sql-driver/mysql"

But, be careful, imports are always made from master, so when you directly
import packages - your code can be broken by any changes.

* Naming

Go takes an unusual approach to defining the visibility of an identifier.
If the initial character is an upper case letter, the identifier is exported (public),
otherwise it is not:

    PublicIdentifier
    privateIdentifier
    _PrivateIdentifier

Example

    package fmt

    func Println(a ...interface{}) (n int, err error) {
        ...
    }

    func newPrinter() *pp {
        ...
    }

* Types

Implicit type conversions are not allowed for numeric types

    var v1 int32 = 1
    var v2 int64 = 2
    v2 += v1 // WRONG!!!

There is no type aliasing, each type

.code src/type_aliasing.go

* Functions

In Go function is a first order object, it can be treated as a value

    v := func(){
        ...
    }

Closures also allowed

    func getAdder(v int) func(int) int {
        return func(arg int) int {
            return v + arg
        }
    }

* Function arguments

This is possible to call function with variadic argument count
using ... syntax, but they must have the same type.

.code src/function_var_args.go

* More variadic args

Variadic args can not be expanded over ordinary arguments like

    func foo(a, b, c int) {
        ...
    }

    foo(args...) // WRONG!!!

So this is only syntax sugar that allows not to declare slices in    argument

Keyword arguments are not allowed :-(

* Datatypes

- Numerics(int, uint/int[8, 16, 32, 64], byte, float[32, 64], complex[64, 128], rune)
- boolean
- string
- array
- slice
- map
- struct type
- channel
- pointer type
- func type

* Reference types vs Value types

Only three datatypes in go are reference types

- map
- slice
- channel

They should be initialized with special builtin function make

    make(chan int)
    make([]int, 2, 3)
    make(map[int]string)

In contrast to python arrays are passed by value, but content of an array
can be changed, so it is not immutable.

* Pass by pointer vs Pass by value

Go has pointers

    i := 1
    ptr := &i
    *ptr = 3 // Now i == 3

Everything is passed by value if pointer is not declared explicitly,
except reference types (map, slice, channel, interfaces)

.code src/array_arg.go

* Arrays and slices

Array declaration

    var a [256]byte // Size is always known in compile time
    b := [...]string{"Penn", "Teller"} // Length is determined by compiler

Slice declaration

    var slice1 []byte             // empty slice
    slice2 := make([]byte, 10)    // Slice with specified length
    slice3 := make([]byte, 10, 20) // Slice with specified length and capacity

Builtins for manipulating and measuring slices append, len, cap

    slice := make([]byte, 5, 10) // len(slice) == 5, cap(slice) == 10
    slice = append(slice, 42)    // len(slice) == 6, cap(slice) == 10

* Slice memory layout

Slice variable is a value, composing of three words

.image images/go-slices-usage-and-internals_slice-struct.png

Proof:

	slice := []int{1, 2, 3, 5, 6}
	println(unsafe.Sizeof(slice)) // 24 on 64-bit machines

ptr - is a pointer on actual memory
len - count of elements
cap - how many elements can be put inside without additional allocations

* Many slices can be pointed to the same memory

.image images/go-slices-usage-and-internals_slice-1.png

.image images/go-slices-usage-and-internals_slice-2.png

* Array slicing

Many slices can be created over an existing array

    slice := arr[:]
    slice2 := arr[2:]    // copy since element with index 2
    slice3 := arr[2:4:5] // 4 - position of len, 5 - position of capacity

There is no way to reverse an array or get subset of elements like in Python

    l[::-1]
    l[1:10:2]

* Maps

Maps are made by hash map

Declaration

    var m map[string]int

Initialization

    m := make(map[string]int)

Or via map literal

	m := map[string]int{
		"abc": 1,
		"edf": 2,
		"cnv":  3,
	}

Maps, Slices, Arrays, Channels and functions cannot be used as keys

* Iteration over map

    for key, value := range m {

    }

Note: iteration order it not determined not only between process run,
but between two distinct iterations.

* Interfaces, Structs, Methods

* Structs

Golang allows creating composite types - structs

    type MyStruct struct{
        IntField int
        StrField  string
    }

Like in packages, identifier start with capital letter
are "public" e.g can be used by code from other packages,
otherwise - "private".

* Struct methods

We can define method bounded to specific type.

.code src/method_over_int.go

i acts as self in python and is called receiver.

* Receivers

Receiver can be declared as value or pointer

    type MyStruct struct {
        Field int
    }

    func (m MyStruct) ValueReceiver() {
        m.Field = 3
    }

    func (m *MyStruct) PointerReceiver() {
        m.Field = 4
    }

The main difference is that methods with value receiver cannot
modify caller object.

* Example

	m := MyStruct{
		Field: 1,
	}

	m.ValueReceiver()
	fmt.Println(m.Field) // 1
	m.PointerReceiver()
	fmt.Println(m.Field) // 4

* Interfaces

Golang has interfaces - group of function signatures
to be implemented.

    type Reader interface{
        Read([]byte) (int, error)
    }

Types are not directly marked with interfaces, instead
as python does golang uses duck-typing to check whether concrete
type implements interface or not.

* Method sets

All methods that have type T as a receiver constitute
type T method set.

All methods that have type *T or type T as a receiver constitute
type *T method set.

Internally methods set - is ordered list of method signatures.
To implement an interface type should have all interface signatures
in his method set.

* Internal structure

Internally interface variable consist of 2 words

- Pointer to actual object
- Pointer to interface method set

.image images/interface.png

* Proof

	type iface interface{}
	var v iface
	println(unsafe.Sizeof(v)) // 8 or 16 depend on system

So you should never declare functions such as

    func foo(iface &MyInterface)

As far as interface{} type has empty method set, it can
receive any values and act as an universal pointer.

* Type switch

Golang has unusual construct as type switch

    switch t := v.(type) {
    default:
        fmt.Printf("unexpected type %T\n", t)
    case bool:
        fmt.Printf("boolean %t\n", t)
    case int:
        fmt.Printf("integer %d\n", t)
    case *bool:
        fmt.Printf("pointer to boolean %t\n", *t)
    case *int:
        fmt.Printf("pointer to integer %d\n", *t)
    }

* Rule of thumb for Go

Accept interfaces, return structs

* Error handling

Golang has no special control flow for handling exception.
Errors are just value returned  from function.
Maybe the most simple interface from standard library package builtin.

    type error interface {
        Error() string
    }

Such error handling has advantage of performance (Google doest like exceptions)
like in plain old C, but code full of error checks becomes messy, more over
error does not carry any context.

* But there is a rescue

    github.com/pkg/errors

Package allows to make smart errors.
New error should be produced by constructor

    func New(text string) error

On each stage error should be wrapped before sending further

    func Wrap(err error, message string) error

* Example

    func foo() error {
        err := errors.New("foo")
        return err
    }

    func bar() error {
        err := foo()
        return errors.Wrap(err, "bar")
    }

Trace:

    main.baz
        /home/stgleb/workspace/golang_presentation/src/errors_package.go:20
    main.main
        /home/stgleb/workspace/golang_presentation/src/errors_package.go:28
    runtime.main
        /usr/local/go/src/runtime/proc.go:183
    runtime.goexit
        /usr/local/go/src/runtime/asm_amd64.s:2086

* Defer, Panic, Recover

* Concurrency

* Q&A

Questions?
